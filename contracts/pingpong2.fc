#include "imports/stdlib.fc";

int slice_hash(slice s) asm "HASHSU";
int equal_slices(slice a, slice b) asm "SDEQ";

;; storage variables
global cell ctx_str;
global cell ctx_address1;

() load_data() impure {
  var ds = get_data().begin_parse();
  ctx_str = ds~load_ref();
  ctx_address1 = ds~load_ref();
  ds.end_parse();
}

() save_data() impure {
  set_data(
    begin_cell()
      .store_ref(ctx_str)
      .store_ref(ctx_address1)
      .end_cell()
  );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return ();
  }
  slice cs = in_msg_full.begin_parse();
  cs~skip_bits(4);
  var sender_address = cs~load_msg_addr();

  load_data();
  slice current = ctx_str.begin_parse();
  slice ping = begin_cell().store_slice("ping").end_cell().begin_parse();

  ~strdump("sender_address");
  ~dump(sender_address);
  ~strdump("ctx_address1");
  ~dump(ctx_address1.begin_parse());
  if (equal_slices(sender_address, ctx_address1.begin_parse()) == -1) {
    ~strdump("sender_address and ctx_address1 are equal");
  } else {
    ~strdump("sender_address and ctx_address1 are not equal");
  }

  if (equal_slices(current,ping) == -1) {
    cell c = begin_cell().store_slice("pong").end_cell();
    ctx_str = c;
    save_data();
    return ();
  } else  {
    cell c = begin_cell().store_slice("ping").end_cell();
    ctx_str = c;
    save_data();
    return ();
  }
}

cell get_str() method_id {
  load_data();
  return ctx_str;
}